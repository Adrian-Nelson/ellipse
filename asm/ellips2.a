OSWRCH = $FFEE

xvar_index   = $70
yvar_index   = $71
counter      = $72
multiplier   = $73
multiplicand = $77
product      = $7b

result_index        = $83
product_index       = $83
param1_index        = $84
multiplicand_index  = $84
multiplier_index    = $85
depth               = $87
quadrant            = $88
tempx               = $89
tempxHigh           = $8a
tempy               = $8b
tempyHigh           = $8c
dir                 = $8d

* = $2400

; ***************************************************************************************
main
draw_ellipse
    lda #0                              ;
    sta depth                           ;

    lda #a - variables_start            ;
    ldx #a - variables_start            ;
    ldy #aa - variables_start           ;
    jsr multiply16                      ; AA = A*A

    lda #b - variables_start            ;
    ldx #b - variables_start            ;
    ldy #bb - variables_start           ;
    jsr multiply16                      ; BB = B*B

    lda #0                              ;
    ldx #yyaa - variables_start         ;
    jsr set_variable32_to_a             ; YYAA = 0

    lda #aa - variables_start           ;
    ldx #bb - variables_start           ;
    ldy #aabb - variables_start         ;
    jsr multiply32                      ; AABB = AA*BB

    ldx #aa - variables_start           ;
    ldy #yyaa_diff - variables_start    ;
    jsr copy32                          ; YYAA_DIFF = AA

    lda #0                              ;
    sta state                           ;
    sta state + 1                       ; reset state of each quadrant
    sta state + 2                       ;
    sta state + 3                       ;

    ldx #a - variables_start            ;
    ldy #x1 - variables_start           ;
    jsr negate16                        ; X1 = -A

    lda #a - variables_start            ;
    ldx #b - variables_start            ;
    ldy #t2 - variables_start           ;
    jsr multiply16                      ; T2 = A*B

    ldx #t2 - variables_start           ;
    ldy #t1 - variables_start           ;
    jsr negate32                        ; T1 = -T2

    ldx #aabb - variables_start         ;
    ldy #tt1 - variables_start          ;
    jsr copy32                          ; TT1 = AABB

    lda #b - variables_start            ;
    ldx #t1 - variables_start           ;
    ldy #bt1 - variables_start          ;
    jsr multiply32                      ; BT1 = B*T1

    lda #s - variables_start            ;
    ldx #t1 - variables_start           ;
    ldy #st1 - variables_start          ;
    jsr multiply32                      ; ST1 = S*T1


    ldx #a - variables_start            ;
    ldy #x2 - variables_start           ;
    jsr copy16                          ; X2 = A

    ldx #aabb - variables_start         ;
    ldy #tt2 - variables_start          ;
    jsr copy32                          ; TT2=AABB

    ldx #bt1 - variables_start          ;
    ldy #bt2 - variables_start          ;
    jsr negate32                        ; BT2=-BT1

    ldx #st1 - variables_start          ;
    ldy #st2 - variables_start          ;
    jsr negate32                        ; ST2=-ST1

    ldx #bb - variables_start           ;
    ldy #bb2 - variables_start          ;
    jsr div2_32                         ; BB2 = BB/2

    lda #s - variables_start            ;
    ldx #b - variables_start            ;
    ldy #sb - variables_start           ;
    jsr multiply32                      ; SB = S*B

    lda #s - variables_start            ;
    ldx #s - variables_start            ;
    ldy #ss - variables_start           ;
    jsr multiply32                      ; SS = S*S

    lda #0                              ;
    ldx #y - variables_start            ;
    jsr set_variable16_to_a             ; Y = 0

fory_loop
    ; first add_point
    lda #x1 - variables_start           ;
    ldx #ox1 - variables_start          ;
    ldy #increment - variables_start    ;
    jsr subtract16                      ; increment=X1-OX1

    ldx #increment - variables_start    ;
    jsr sgn16                           ; increment=SGN(increment)

    lda increment                       ;
    clc                                 ;
    adc #7                              ; A = 7 + sgn(x1-ox1)      (i.e. the direction)
    ldx #0                              ; X is the quadrant to use
    ldy #x1 - variables_start           ; Y is the x coordinate to use
    jsr add_point                       ;


    ; second add_point
    lda #x2 - variables_start           ;
    ldx #ox2 - variables_start          ;
    ldy #increment - variables_start    ;
    jsr subtract16                      ; increment=X2-OX2

    ldx #increment - variables_start    ;
    jsr sgn16                           ; increment=SGN(increment)

    lda increment                       ;
    clc                                 ;
    adc #7                              ; A = 7 + sgn(x2-ox2)      (i.e. the direction)
    ldx #1                              ; X is the quadrant to use
    ldy #x2 - variables_start           ; Y is the x coordinate to use
    jsr add_point                       ;


    ldx #x1 - variables_start           ;
    ldy #ox1 - variables_start          ;
    jsr copy16                          ; OX1 = X1

    ldx #x2 - variables_start           ;
    ldy #ox2 - variables_start          ;
    jsr copy16                          ; OX2 = X2

    lda #aabb - variables_start         ;
    ldx #yyaa - variables_start         ;
    ldy #dd - variables_start           ; DD=AABB-YYAA
    jsr subtract32                      ;

    ; right half
repeat_loop1
    lda t2 + 3                          ;
    bpl +                               ;
    jmp inc_x2_t2                       ; IF T2<0 THEN GOTO ...
+
    ora t2 + 2                          ;
    ora t2 + 1                          ;
    ora t2 + 0                          ;
    beq post_loop1                      ; IF T2=0 THEN GOTO ...

    lda #tt2 - variables_start          ;
    ldx #dd - variables_start           ;
    ldy #d1 - variables_start           ;
    jsr subtract32                      ; D1=TT2-DD

    lda #bt2 - variables_start          ;
    ldx #bb2 - variables_start          ;
    ldy #bd - variables_start           ;
    jsr add32                           ; BD=BT2+BB2

    lda #bd - variables_start           ;
    ldx #d1 - variables_start           ;
    ldy #temp - variables_start         ;
    jsr subtract32                      ; temp = BD-D1

    lda temp+3                          ;
    bpl +                               ;
    jmp dec_x2_t2                       ; IF temp<0 THEN GOTO ...
+

    lda #bd - variables_start           ;
    ldx #d1 - variables_start           ;
    ldy #temp - variables_start         ;
    jsr add32                           ; temp = BD+D1

    lda temp+3                          ;
    bpl post_loop1                       ;
    jmp inc_x2_t2                       ; IF temp<0 THEN GOTO ...

post_loop1
    lda #x2 - variables_start           ;
    ldx #ox2 - variables_start          ;
    ldy #increment - variables_start    ;
    jsr subtract16                      ; increment=X2-OX2

    ldx #increment - variables_start    ;
    jsr sgn16                           ; increment=SGN(increment)

    lda #ox2 - variables_start          ;
    ldx #increment - variables_start    ;
    ldy #x - variables_start            ;
    jsr add16                           ; x = ox2 + increment

    ; loop to add points in a horizontal line
-
    lda x2                              ;
    cmp x                               ;
    bne +                               ;
    lda x2 + 1                          ;
    cmp x + 1                           ;
    beq done_first_half                 ; if (x == x2) then goto done1

+
    lda #4                              ;
    clc                                 ;
    adc increment                       ; A = 4 + increment       (i.e. the direction)
    ldx #1                              ; X is the quadrant to use
    ldy #x - variables_start            ; Y is the x coordinate to use
    jsr add_point                       ;

    lda #x - variables_start            ;
    ldx #increment - variables_start    ;
    ldy #x - variables_start            ;
    jsr add16                           ; x = x + increment

    jmp -                               ;

done_first_half

    ; left half
repeat_loop2
    lda t1 + 3                          ;
    bmi ++                              ;
    ora t1 + 2                          ;
    ora t1 + 1                          ;
    ora t1 + 0                          ;
    beq post_loop2                      ; IF T=0 THEN GOTO ...
    jmp dec_x1_t1                       ; IF T>0 THEN GOTO ...
++

    lda #tt1 - variables_start          ;
    ldx #dd - variables_start           ;
    ldy #d1 - variables_start           ;
    jsr subtract32                      ; D1=TT1-DD

    lda #bb2 - variables_start          ;
    ldx #bt1 - variables_start          ;
    ldy #bd - variables_start           ;
    jsr subtract32                      ; BD=BB2-BT1

    lda #bd - variables_start           ;
    ldx #d1 - variables_start           ;
    ldy #temp - variables_start         ;
    jsr subtract32                      ; temp = BD-D1

    lda temp+3                          ;
    bpl ++                              ;
    jmp inc_x1_t1                       ;
++

    lda #bd - variables_start           ;
    ldx #d1 - variables_start           ;
    ldy #temp - variables_start         ;
    jsr add32                           ; temp = BD+D1

    lda temp+3                          ;
    bpl post_loop2                      ;
    jmp dec_x1_t1                       ;

post_loop2
    lda #x1 - variables_start           ;
    ldx #ox1 - variables_start          ;
    ldy #increment - variables_start    ;
    jsr subtract16                      ; increment=X1-OX1

    ldx #increment - variables_start    ;
    jsr sgn16                           ; increment=SGN(increment)

    lda #ox1 - variables_start          ;
    ldx #increment - variables_start    ;
    ldy #x - variables_start            ;
    jsr add16                           ; x = ox1 + increment

    ; loop to add points in a horizontal line
-
    lda x1                              ;
    cmp x                               ;
    bne +                               ;
    lda x1 + 1                          ;
    cmp x + 1                           ;
    beq done_row                        ; if (x == x1) then goto done2

+
    lda #4                              ;
    clc                                 ;
    adc increment                       ; A = 4 + increment       (i.e. the direction)
    ldx #0                              ; X is the quadrant to use
    ldy #x - variables_start            ; Y is the x coordinate to use
    jsr add_point                       ;

    lda #x - variables_start            ;
    ldx #increment - variables_start    ;
    ldy #x - variables_start            ;
    jsr add16                           ; x = x + increment

    jmp -                               ;

done_row
    ldx #st2 - variables_start          ;
    ldy #tt2 - variables_start          ;
    jsr decrement32                     ; TT2-=ST2

    ldx #st2 - variables_start          ;
    ldy #tt2 - variables_start          ;
    jsr decrement32                     ; TT2-=ST2    (again)

    ldx #ss - variables_start           ;
    ldy #tt2 - variables_start          ;
    jsr increment32                     ; TT2+=SS

    ldx #st1 - variables_start          ;
    ldy #tt1 - variables_start          ;
    jsr decrement32                     ; TT1-=ST1

    ldx #st1 - variables_start          ;
    ldy #tt1 - variables_start          ;
    jsr decrement32                     ; TT1-=ST1    (again)

    ldx #ss - variables_start           ;
    ldy #tt1 - variables_start          ;
    jsr increment32                     ; TT1+=SS

    ldx #ss - variables_start           ;
    ldy #st2 - variables_start          ;
    jsr decrement32                     ; ST2-=SS

    ldx #ss - variables_start           ;
    ldy #st1 - variables_start          ;
    jsr decrement32                     ; ST1-=SS

    ldx #yyaa_diff - variables_start    ;
    ldy #yyaa - variables_start         ;
    jsr increment32                     ; YYAA+=YYA_DIFF

    ldx #aa - variables_start           ;
    ldy #yyaa_diff - variables_start    ;
    jsr increment32                     ; YYAA_DIFF+=AA

    ldx #aa - variables_start           ;
    ldy #yyaa_diff - variables_start    ;
    jsr increment32                     ; YYAA_DIFF+=AA   (again)

    ldx #sb - variables_start           ;
    ldy #bt2 - variables_start          ;
    jsr decrement32                     ; BT2-=SB

    ldx #sb - variables_start           ;
    ldy #bt1 - variables_start          ;
    jsr decrement32                     ; BT1-=SB

    ldx #s - variables_start            ;
    ldy #t2 - variables_start           ;
    jsr decrement32                     ; T2-=S

    ldx #s - variables_start            ;
    ldy #t1 - variables_start           ;
    jsr decrement32                     ; T1-=S

    inc y                               ;
    bne +                               ;
    inc y+1                             ; Y+=1
+

    lda y                               ;
    cmp b                               ;
    bne +                               ;
    lda y+1                             ;
    cmp b+1                             ;
    beq do_last_row                     ;
+
    jmp fory_loop                       ; IF B != Y GOTO fory_loop

do_last_row

    ; plot any pending un-plotted pixels in each quadrant before drawing the final top and bottom horizontal lines
    lda #0                              ;
    sta quadrant                        ;
-
    jsr finish_off                      ;
    inc quadrant                        ;
    lda quadrant                        ;
    cmp #4                              ;
    bcc -                               ;

    ; draw final top line
    jsr draw_hline                      ; draw lines:B=-B

    ldx #x1 - variables_start           ;
    ldy #x1 - variables_start           ;
    jsr negate16                        ; X1 = -X1

    ldx #x2 - variables_start           ;
    ldy #x2 - variables_start           ;
    jsr negate16                        ; X2 = -X2

    ; draw final bottom line
draw_hline
    lda #4                              ;
    sta plot_type                       ;
    ldx #x1 - variables_start           ;
    ldy #b - variables_start            ;
    jsr plot_xy                         ; MOVE  X1*4, B*4

    lda #5                              ;
    sta plot_type                       ;
    ldx #x2 - variables_start           ;
    ldy #b - variables_start            ;
    jsr plot_xy                         ; DRAW  X2*4, B*4

    ldx #b - variables_start            ;
    ldy #b - variables_start            ;
    jmp negate16                        ; B = -B

; ***************************************************************************************
inc_x2_t2
    inc x2                              ;
    bne +                               ;
    inc x2 + 1                          ; X2+=1
+
    ldx #b - variables_start            ;
    ldy #t2 - variables_start           ;
    jsr increment32                     ; T2+=B

    ldx #bt2 - variables_start          ;
    ldy #tt2 - variables_start          ;
    jsr increment32                     ; TT2+=BT2

    ldx #bt2 - variables_start          ;
    ldy #tt2 - variables_start          ;
    jsr increment32                     ; TT2+=BT2 (again)

    ldx #bb - variables_start           ;
    ldy #tt2 - variables_start          ;
    jsr increment32                     ; TT2+=BB

    ldx #bb - variables_start           ;
    ldy #bt2 - variables_start          ;
    jsr increment32                     ; BT2+=BB

    ldx #sb - variables_start           ;
    ldy #st2 - variables_start          ;
    jsr increment32                     ; ST2+=SB

    jmp repeat_loop1                    ;

; ***************************************************************************************
dec_x2_t2
    lda x2                              ;
    bne +                               ;
    dec x2 + 1                          ; X2-=1
+
    dec x2                              ;

    ldx #b - variables_start            ;
    ldy #t2 - variables_start           ;
    jsr decrement32                     ; T2-=B

    ldx #bt2 - variables_start          ;
    ldy #tt2 - variables_start          ;
    jsr decrement32                     ; TT2-=BT2

    ldx #bt2 - variables_start          ;
    ldy #tt2 - variables_start          ;
    jsr decrement32                     ; TT2-=BT2 (again)

    ldx #bb - variables_start           ;
    ldy #tt2 - variables_start          ;
    jsr increment32                     ; TT2+=BB

    ldx #bb - variables_start           ;
    ldy #bt2 - variables_start          ;
    jsr decrement32                     ; BT2-=BB

    ldx #sb - variables_start           ;
    ldy #st2 - variables_start          ;
    jsr decrement32                     ; ST2-=SB

    jmp repeat_loop1                    ;

; ***************************************************************************************
inc_x1_t1
    inc x1                              ;
    bne +                               ;
    inc x1 + 1                          ; X1+=1
+
    ldx #b - variables_start            ;
    ldy #t1 - variables_start           ;
    jsr increment32                     ; T1+=B

    ldx #bt1 - variables_start          ;
    ldy #tt1 - variables_start          ;
    jsr increment32                     ; TT1+=BT1

    ldx #bt1 - variables_start          ;
    ldy #tt1 - variables_start          ;
    jsr increment32                     ; TT1+=BT1 (again)

    ldx #bb - variables_start           ;
    ldy #tt1 - variables_start          ;
    jsr increment32                     ; TT1+=BB

    ldx #bb - variables_start           ;
    ldy #bt1 - variables_start          ;
    jsr increment32                     ; BT1+=BB

    ldx #sb - variables_start           ;
    ldy #st1 - variables_start          ;
    jsr increment32                     ; ST1+=SB

    jmp repeat_loop2                    ;

; ***************************************************************************************
dec_x1_t1
    lda x1                              ;
    bne +                               ;
    dec x1 + 1                          ; X1-=1
+
    dec x1                              ;

    ldx #b - variables_start            ;
    ldy #t1 - variables_start           ; T1-=B
    jsr decrement32                     ;

    ldx #bt1 - variables_start          ;
    ldy #tt1 - variables_start          ;
    jsr decrement32                     ; TT1-=BT1

    ldx #bt1 - variables_start          ;
    ldy #tt1 - variables_start          ;
    jsr decrement32                     ; TT1-=BT1 (again)

    ldx #bb - variables_start           ;
    ldy #tt1 - variables_start          ;
    jsr increment32                     ; TT1+=BB

    ldx #bb - variables_start           ;
    ldy #bt1 - variables_start          ;
    jsr decrement32                     ; BT1-=BB

    ldx #sb - variables_start           ;
    ldy #st1 - variables_start          ;
    jsr decrement32                     ; ST1-=SB

    jmp repeat_loop2                    ;

; ***************************************************************************************
;
; Y = A * X
;
; multiplies two 32 bit unsigned integers into a 32 bit result
;
; On Entry:
;   The registers are the byte offsets from variables_start to the variables:
;   A = multiplier      (4 bytes)
;   X = multiplicand    (4 bytes)
;   Y = result          (4 bytes)
;
; ***************************************************************************************
multiply32
    sta multiplier_index                ;
    stx multiplicand_index              ;
    sty product_index                   ;

    tax
    ldy #multiplier                     ;
    jsr copy4_to_zp                     ;

    ldx multiplicand_index              ;
    ldy #multiplicand                   ;
    jsr copy4_to_zp                     ;

    lda #32                             ; set binary count to 32
    sta counter                         ;
    lda #0                              ;
    sta product + 4                     ; clear upper half of product
    sta product + 5                     ;
    sta product + 6                     ;
    sta product + 7                     ;
-
    lsr multiplier + 3                  ; shift multiplier right
    ror multiplier + 2                  ;
    ror multiplier + 1                  ;
    ror multiplier + 0                  ;
    bcc +                               ; go rotate right if c = 0

    lda product + 4                     ; get upper half of product and add multiplicand to it
    clc                                 ;
    adc multiplicand                    ;
    sta product + 4                     ;

    lda product + 5                     ;
    adc multiplicand + 1                ;
    sta product + 5                     ;

    lda product + 6                     ;
    adc multiplicand + 2                ;
    sta product + 6                     ;

    lda product + 7                     ;
    adc multiplicand + 3                ;

+
    ror                                 ; rotate partial product right
    sta product + 7                     ;
    ror product + 6                     ;
    ror product + 5                     ;
    ror product + 4                     ;
    ror product + 3                     ;
    ror product + 2                     ;
    ror product + 1                     ;
    ror product + 0                     ;
    dec counter                         ; decrement bit count and
    bne -                               ; loop until 32 bits are done

    ; copy result (4 bytes)
    ldx product_index                   ;
    ldy #3                              ;
-
    lda product,Y                       ;
    sta variables_start + 3,X           ;
    dex                                 ;
    dey                                 ;
    bpl -                               ;
    rts                                 ;

; ***************************************************************************************
plot_block
    !word 0                             ; NOTE: These bytes are reversed
    !word 0                             ; when sending to the VDU drivers
plot_type
    !byte 5                             ; PLOT type
    !byte 25                            ; VDU 25 for PLOT

; ***************************************************************************************
; PLOT plot_type, centreX + variables[X],centreY + variables[Y]
plot_xy
    lda variables_start,X               ;
    clc                                 ;
    adc centrex                         ;
    sta plot_block + 3                  ;
    lda variables_start + 1,X           ;
    adc centrex + 1                     ;
    sta plot_block + 2                  ;

    lda variables_start,Y               ;
    clc                                 ;
    adc centrey                         ;
    sta plot_block + 1                  ;
    lda variables_start + 1,Y           ;
    adc centrey + 1                     ;
    sta plot_block + 0                  ;

    jmp mult_by_four_and_plot           ;

; ***************************************************************************************
;
; MOVE cx + lastMoveX, cy + lastMoveX
; DRAW cx + lastBlueX, cy + lastBlueY
;
; On Entry:
;   X = quadrant
;
; ***************************************************************************************
draw_line
    lda #4                              ; MOVE
    sta plot_type                       ;

    lda lastMoveXLow,x                  ;
    clc                                 ;
    adc centrex                         ;
    sta plot_block + 3                  ;

    lda lastMoveXHigh,x                 ;
    adc centrex + 1                     ;
    sta plot_block + 2                  ;

    lda lastMoveYLow,x                  ;
    clc                                 ;
    adc centrey                         ;
    sta plot_block + 1                  ;

    lda lastMoveYHigh,x                 ;
    adc centrey + 1                     ;
    sta plot_block + 0                  ;

    jsr mult_by_four_and_plot           ;


    lda #5                              ; DRAW
    sta plot_type                       ;

    ldx quadrant                        ;
    lda lastBlueXLow,x                  ;
    clc                                 ;
    adc centrex                         ;
    sta plot_block + 3                  ;

    lda lastBlueXHigh,x                 ;
    adc centrex + 1                     ;
    sta plot_block + 2                  ;

    lda lastBlueYLow,x                  ;
    clc                                 ;
    adc centrey                         ;
    sta plot_block + 1                  ;

    lda lastBlueYHigh,x                 ;
    adc centrey + 1                     ;
    sta plot_block + 0                  ;

mult_by_four_and_plot
    asl plot_block + 1                  ;
    rol plot_block                      ;
    asl plot_block + 1                  ;
    rol plot_block                      ; multiply coordinates by four
    asl plot_block + 3                  ;
    rol plot_block + 2                  ;
    asl plot_block + 3                  ;
    rol plot_block + 2                  ;

    ldx #5                              ;
-
    lda plot_block,X                    ;
    jsr OSWRCH                          ;
    dex                                 ;
    bpl -                               ;
    rts                                 ;

; ***************************************************************************************
plot_point
    lda #69                             ; PLOT 69 (point)
    sta plot_type                       ;

    lda pixelx                          ;
    clc                                 ;
    adc centrex                         ;
    sta plot_block + 3                  ;

    lda pixelx + 1                      ;
    adc centrex + 1                     ;
    sta plot_block + 2                  ;

    lda pixely                          ;
    clc                                 ;
    adc centrey                         ;
    sta plot_block + 1                  ;

    lda pixely + 1                      ;
    adc centrey + 1                     ;
    sta plot_block + 0                  ;

    jmp mult_by_four_and_plot           ;

; ***************************************************************************************
copy4_to_zp
    lda variables_start,X               ;
    sta $00,Y                           ;
    lda variables_start + 1,X           ;
    sta $01,Y                           ;
    lda variables_start + 2,X           ;
    sta $02,Y                           ;
    lda variables_start + 3,X           ;
    sta $03,Y                           ;
    rts                                 ;

; ***************************************************************************************
copy2_to_zp
    lda variables_start,X               ;
    sta $00,Y                           ;
    lda variables_start + 1,X           ;
    sta $01,Y                           ;
    rts                                 ;

; ***************************************************************************************
set_variable16_to_a
    sta variables_start,X               ;
    lda #0                              ;
    sta variables_start + 1,X           ;
    rts                                 ;

; ***************************************************************************************
set_variable32_to_a
    sta variables_start,X               ;
    lda #0                              ;
    sta variables_start + 1,X           ;
    sta variables_start + 2,X           ;
    sta variables_start + 3,X           ;
    rts                                 ;

; ***************************************************************************************
just_copy
    sta variables_start + 1,Y           ;
    lda variables_start,X               ;
    sta variables_start,Y               ;
    rts                                 ;

; ***************************************************************************************
abs16
    lda variables_start + 1,X           ;
    bpl just_copy                       ;
    ; fall through...

; ***************************************************************************************
;
; Y = -X
;
; ***************************************************************************************
negate16
    lda #0                              ;
    sec                                 ;
    sbc variables_start,X               ;
    sta variables_start,Y               ;
    lda #0                              ;
    sbc variables_start + 1,X           ;
    sta variables_start + 1,Y           ;
    rts                                 ;

; ***************************************************************************************
;
; Y = -X
;
; ***************************************************************************************
negate32
    lda #0                              ;
    sec                                 ;
    sbc variables_start,X               ;
    sta variables_start,Y               ;
    lda #0                              ;
    sbc variables_start + 1,X           ;
    sta variables_start + 1,Y           ;
    lda #0                              ;
    sbc variables_start + 2,X           ;
    sta variables_start + 2,Y           ;
    lda #0                              ;
    sbc variables_start + 3,X           ;
    sta variables_start + 3,Y           ;
    rts                                 ;

; ***************************************************************************************
;
; Y = X
;
; ***************************************************************************************
copy32
    lda variables_start + 3,X           ;
    sta variables_start + 3,Y           ;
    lda variables_start + 2,X           ;
    sta variables_start + 2,Y           ;
copy16
    lda variables_start + 1,X           ;
    sta variables_start + 1,Y           ;
    lda variables_start,X               ;
    sta variables_start,Y               ;
    rts                                 ;

; ***************************************************************************************
;
; Y = A-X
;
; ***************************************************************************************
subtract16
    sty result_index                    ;
    sta param1_index                    ;
    tay                                 ;

    lda variables_start,Y               ;
    sec                                 ;
    sbc variables_start,X               ;
    ldy result_index                    ;
    sta variables_start,Y               ;
    ldy param1_index                    ;
    lda variables_start + 1,Y           ;
    sbc variables_start + 1,X           ;
    ldy result_index                    ;
    sta variables_start + 1,Y           ;
    rts                                 ;

; ***************************************************************************************
;
; Y = A-X
;
; ***************************************************************************************
subtract32
    sty result_index                    ;
    sta param1_index                    ;
    tay                                 ;

    lda variables_start,Y               ;
    sec                                 ;
    sbc variables_start,X               ;
    ldy result_index                    ;
    sta variables_start,Y               ;

    ldy param1_index                    ;
    lda variables_start + 1,Y           ;
    sbc variables_start + 1,X           ;
    ldy result_index                    ;
    sta variables_start + 1,Y           ;

    ldy param1_index                    ;
    lda variables_start + 2,Y           ;
    sbc variables_start + 2,X           ;
    ldy result_index                    ;
    sta variables_start + 2,Y           ;

    ldy param1_index                    ;
    lda variables_start + 3,Y           ;
    sbc variables_start + 3,X           ;
    ldy result_index                    ;
    sta variables_start + 3,Y           ;
    rts                                 ;

; ***************************************************************************************
;
; Y = Y-X
;
; ***************************************************************************************
decrement32
    lda variables_start,Y               ;
    sec                                 ;
    sbc variables_start,X               ;
    sta variables_start,Y               ;
    lda variables_start + 1,Y           ;
    sbc variables_start + 1,X           ;
    sta variables_start + 1,Y           ;

    lda variables_start + 2,Y           ;
    sbc variables_start + 2,X           ;
    sta variables_start + 2,Y           ;

    lda variables_start + 3,Y           ;
    sbc variables_start + 3,X           ;
    sta variables_start + 3,Y           ;
    rts                                 ;

; ***************************************************************************************
;
; Y = A+X
;
; ***************************************************************************************
add32
    sty result_index                    ;
    sta param1_index                    ;
    tay                                 ;

    lda variables_start,Y               ;
    clc                                 ;
    adc variables_start,X               ;
    ldy result_index                    ;
    sta variables_start,Y               ;

    ldy param1_index                    ;
    lda variables_start + 1,Y           ;
    adc variables_start + 1,X           ;
    ldy result_index                    ;
    sta variables_start + 1,Y           ;

    ldy param1_index                    ;
    lda variables_start + 2,Y           ;
    adc variables_start + 2,X           ;
    ldy result_index                    ;
    sta variables_start + 2,Y           ;

    ldy param1_index                    ;
    lda variables_start + 3,Y           ;
    adc variables_start + 3,X           ;
    ldy result_index                    ;
    sta variables_start + 3,Y           ;
    rts                                 ;

; ***************************************************************************************
;
; Y = Y+X
;
; ***************************************************************************************
increment32
    lda variables_start,Y               ;
    clc                                 ;
    adc variables_start,X               ;
    sta variables_start,Y               ;

    lda variables_start + 1,Y           ;
    adc variables_start + 1,X           ;
    sta variables_start + 1,Y           ;

    lda variables_start + 2,Y           ;
    adc variables_start + 2,X           ;
    sta variables_start + 2,Y           ;

    lda variables_start + 3,Y           ;
    adc variables_start + 3,X           ;
    sta variables_start + 3,Y           ;
    rts                                 ;

; ***************************************************************************************
;
; Y = A+X
; preserves X
;
; ***************************************************************************************
add16
    sty result_index                    ;
    sta param1_index                    ;
    tay                                 ;

    lda variables_start,Y               ;
    clc                                 ;
    adc variables_start,X               ;
    ldy result_index                    ;
    sta variables_start,Y               ;

    ldy param1_index                    ;
    lda variables_start + 1,Y           ;
    adc variables_start + 1,X           ;
    ldy result_index                    ;
    sta variables_start + 1,Y           ;

    rts                                 ;

; ***************************************************************************************
sgn16
    lda variables_start + 1,X           ;
    bmi negative                        ;
    bne positive                        ;
    ora variables_start + 0,X           ;
    beq iszero                          ;
    ; fall through...

positive
    lda #1                              ;
    sta variables_start + 0,X           ;
    lda #0                              ;
    sta variables_start + 1,X           ;
    rts                                 ;

negative
    lda #255                            ;
    ; fall through...

iszero
    sta variables_start + 0,X           ;
    sta variables_start + 1,X           ;
    rts                                 ;

; ***************************************************************************************
;
; Y = X/2
;
; ***************************************************************************************
div2_32
    lda variables_start + 3,X           ;
    lsr                                 ;
    sta variables_start + 3,Y           ;
    lda variables_start + 2,X           ;
    ror                                 ;
    sta variables_start + 2,Y           ;
div2_16
    lda variables_start + 1,X           ;
    ror                                 ;
    sta variables_start + 1,Y           ;
    lda variables_start + 0,X           ;
    ror                                 ;
    sta variables_start + 0,Y           ;
    rts                                 ;

; ***************************************************************************************
;
; Y = A * X
;
; multiplies two 16 bit unsigned integers into a 32 bit result
;
; On Entry:
;   The registers are the byte offsets from variables_start to the variables:
;   A = multiplier      (2 bytes)
;   X = multiplicand    (2 bytes)
;   Y = result          (4 bytes)
;
; ***************************************************************************************
multiply16
    sta multiplier_index                ;
    stx multiplicand_index              ;
    sty product_index                   ;

    tax
    ldy #multiplier                     ;
    jsr copy2_to_zp                     ;

    ldx multiplicand_index              ;
    ldy #multiplicand                   ;
    jsr copy2_to_zp                     ;

    lda #16                             ; set binary count to 32
    sta counter                         ;
    lda #0                              ;
    sta product + 2                     ; clear upper half of product
    sta product + 3                     ;
-
    lsr multiplier + 1                  ; shift multiplier right
    ror multiplier + 0                  ;
    bcc +                               ; go rotate right if c = 0

    lda product + 2                     ; get upper half of product and add multiplicand to it
    clc                                 ;
    adc multiplicand                    ;
    sta product + 2                     ;

    lda product + 3                     ;
    adc multiplicand + 1                ;

+
    ror                                 ; rotate partial product right
    sta product + 3                     ;
    ror product + 2                     ;
    ror product + 1                     ;
    ror product + 0                     ;
    dec counter                         ; decrement bit count and
    bne -                               ; loop until 16 bits are done

    ; copy result (4 bytes)
    ldx product_index                   ;
    ldy #3                              ;
-
    lda product,Y                       ;
    sta variables_start + 3,X           ;
    dex                                 ;
    dey                                 ;
    bpl -                               ;
return1
    rts                                 ;

; ***************************************************************************************
;
; add_point
;
; On Entry:
;    A      = current direction ('dir')
;    X      = quadrant
;    Y      = X variable to add
;
; ***************************************************************************************
add_point
    sta dir                             ;
    stx quadrant                        ;

    lda variables_start,y               ;
    sta newx                            ; newx = variable[y]
    lda variables_start + 1,y           ;
    sta newx + 1                        ;

    lda y                               ;
    sta newy                            ;
    lda y+1                             ; newy = y
    sta newy + 1                        ;

    jsr add_point_quadrant              ;

    lda newy                            ;
    ora newy + 1                        ;
    beq return1                         ; IF (Y=0) return

    ldx #newy - variables_start         ;
    ldy #newy - variables_start         ;
    jsr negate16                        ; newy = -newy

    ldx #newx - variables_start         ;
    ldy #newx - variables_start         ;
    jsr negate16                        ; newx = -newx

    lda #3                              ;
    sec                                 ;
    sbc quadrant                        ;
    sta quadrant                        ; quadrant = 3-quadrant

    lda #8                              ;
    sec                                 ;
    sbc dir                             ;
    sta dir                             ; dir = 8-dir
    ; fall through...

; ***************************************************************************************
;
; On Entry:
;   quadrant is the quadrant of the ellipse to add to
;   dir is the direction since the last point of the quadrant
;   newx, newy are the 16 bit coordinates of the point to add
;
; ***************************************************************************************
add_point_quadrant
    ; to test the right points are here draw a point and return
    ;lda #69                             ;
    ;sta plot_type                       ;
    ;ldx #newx - variables_start         ;
    ;ldy #newy - variables_start         ;
    ;jmp plot_xy                         ; PLOT 69, newx*4, newy*4

    ldx quadrant                        ;
    lda state,x                         ;
    beq state_zero                      ; if (state[quadrant] == 0) { goto state_zero }
    cmp #1                              ;
    bne state_two                       ; if (state[quadrant] == 2) { goto state_two }
    ; fall through...

; ***************************************************************************************
;
; Handle state one
;
; On Entry:
;   X = quadrant
;   dir = direction
;   newx, newy are the 16 bit coordinates of the point to add
;
; ***************************************************************************************
state_one
    ldy dir                             ;
    lda rootChildren,y                  ;
    sta treepos,x                       ; treepos[quadrant] = rootChildren[dir];

    lda newx                            ;
    sta lastBlueXLow,x                  ;
    lda newx + 1                        ;
    sta lastBlueXHigh,x                 ; lastBlueX[quadrant] = newx;

    lda newy                            ;
    sta lastBlueYLow,x                  ;
    lda newy + 1                        ;
    sta lastBlueYHigh,x                 ; lastBlueY[quadrant] = newy;

    lda direction0,y                    ; d0[quadrant] = direction0[dir];
    sta dir0,x                          ; d1[quadrant] = direction1[dir];
    lda direction1,y                    ; d2[quadrant] = direction2[dir];
    sta dir1,x                          ;
    lda direction2,y                    ;
    sta dir2,x                          ;

    lda #2                              ;
    sta state,x                         ; state[quadrant] = 2;
    rts                                 ;

; ***************************************************************************************
;
; Handle state two
;
; On Entry:
;   X = quadrant
;
; ***************************************************************************************
state_two
    jsr get_child_from_dir              ;
    cmp #255                            ;
    beq out_of_tree                     ; IF newpos == 255 THEN GOTO...

    sta treepos,x                       ; treepos[quadrant] = newpos;
    tay                                 ;
    lda isBlue,y                        ;
    bmi blue_node_found                 ; IF isBlue[newpos] < 0 THEN GOTO...

    ; yellow node
    lda dir                             ;
    ldy stackptr,x                      ;
    sta stack,y                         ; stack[stackptr[quadrant]] = dir;
    inc stackptr,x                      ; stackptr[quadrant]++;
    rts                                 ;

; ***************************************************************************************
;
; Handle state zero
;
; On Entry:
;   X = quadrant
;   newx, newy are the 16 bit coordinates of the point to add
;
; ***************************************************************************************
state_zero
    lda newx                            ;
    sta lastMoveXLow,x                  ; lastMoveX[quadrant] = newx;
    sta lastBlueXLow,x                  ; lastBlueX[quadrant] = newx;
    lda newx + 1                        ;
    sta lastMoveXHigh,x                 ;
    sta lastBlueXHigh,x                 ;

    lda newy                            ;
    sta lastMoveYLow,x                  ;
    sta lastBlueYLow,x                  ; lastMoveY[quadrant] = newy;
    lda newy + 1                        ; lastBlueY[quadrant] = newy;
    sta lastMoveYHigh,x                 ;
    sta lastBlueYHigh,x                 ;

    lda eight_times_table,x             ;
    sta stackptr,x                      ; stackptr[quadrant] = 8*quadrant;
    lda #1                              ;
    sta state,x                         ; state[quadrant] = 1;
    rts                                 ;

blue_node_found
    ; blue node
    lda eight_times_table,x             ;
    sta stackptr,x                      ; stackptr[quadrant] = 8*quadrant;

    lda newx                            ;
    sta lastBlueXLow,x                  ;
    lda newx + 1                        ;
    sta lastBlueXHigh,x                 ; lastBlueX[quadrant] = newx;

    lda newy                            ;
    sta lastBlueYLow,x                  ;
    lda newy + 1                        ;
    sta lastBlueYHigh,x                 ; lastBlueY[quadrant] = newy;
return4
    rts                                 ;

out_of_tree
    jsr draw_line                       ; MOVE cx+lastMoveX, cy+lastMoveY: DRAW cx+lastBlueX, cy+lastBlueY

    ldx quadrant                        ;
    lda treepos,x                       ;
    tay                                 ;
    lda isBlue,y                        ;
    bmi state_zero                      ; if ((isBlue[treepos[quadrant]] & 128) < 0) { GOTO state_zero }

    ; Add the current move to stack
    lda stackptr,x                      ;
    tay                                 ;
    lda dir                             ;
    sta stack,y                         ; stack[stackptr[quadrant]] = dir;
    inc stackptr,x                      ; stackptr[quadrant]++;

    lda #0                              ;
    sta state,x                         ; state[quadrant] = 0

    tay                                 ;
    lda stackptr,x                      ;
    sta end,y                           ; end[depth] = stackptr[quadrant];

    lda lastBlueXLow,x                  ;
    sta newx                            ;
    lda lastBlueXHigh,x                 ;
    sta newx + 1                        ; newx = lastBlueX

    lda lastBlueYLow,x                  ;
    sta newy                            ;
    lda lastBlueYHigh,x                 ;
    sta newy + 1                        ; newy = lastBlueY

    lda eight_times_table,x             ;
    sta i,y                             ;
                                        ; for(i[depth] = 8*quadrant; i[depth] < end[depth]; i[depth]++) {
-
    ldy depth                           ;
    lda i,y                             ;
    cmp end,y                           ;
    bcs return4                         ; if (i[depth] >= end[depth]) return

    tay                                 ;
    lda stack,y                         ;
    sta dir                             ; dir = stack[i];

    tay                                 ; Y = stack[i];
    lda newx                            ;
    clc                                 ;
    adc dxLow,y                         ;
    sta newx                            ;
    lda newx+1                          ;
    adc dxHigh,y                        ;
    sta newx+1                          ; newx += dx[dir];

    lda newy                            ;
    clc                                 ;
    adc dyLow,y                         ;
    sta newy                            ;
    lda newy+1                          ;
    adc dyHigh,y                        ;
    sta newy+1                          ; newy += dy[dir];

    inc depth
    jsr add_point_quadrant              ; add_point_quadrant(pg, quadrant, newx, newy, dir);
    dec depth                           ;

    ldy depth                           ;
    lda i,y                             ;
    clc                                 ;
    adc #1                              ;
    sta i,y                             ; i[depth]++;
    jmp -                               ;

; ***************************************************************************************
finish_off
    ldx quadrant                        ;
    lda state,x                         ;
    beq return3                         ;
    jsr draw_line                       ; MOVE cx+lastMoveX, cy+lastMoveY: DRAW cx+lastBlueX, cy+lastBlueY
    ldx quadrant                        ;
    ; fall through...

; ***************************************************************************************
draw_pixels_since_last_blue
    lda #0                              ;
    sta state,x                         ; state[quadrant] = 0;

    lda stackptr,x                      ;
    sta end                             ; end = stackptr[quadrant];


    lda lastBlueXLow,x                  ;
    sta pixelx                          ;
    lda lastBlueXHigh,x                 ;
    sta pixelx + 1                      ; pixelx = lastBlueX

    lda lastBlueYLow,x                  ;
    sta pixely                          ;
    lda lastBlueYHigh,x                 ;
    sta pixely + 1                      ; pixely = lastBlueY

    lda eight_times_table,x             ;
    sta i                               ;
                                        ; for(int i = 8*quadrant; i < end; i++) {
-
    lda i                               ;
    cmp end                             ;
    bcs return2                         ; if (i >= end) GOTO

    tay                                 ;
    lda stack,y                         ;
;    sta dir                             ; dir = stack[i];

    tay                                 ; Y = stack[i];
    lda pixelx                          ;
    clc                                 ;
    adc dxLow,y                         ;
    sta pixelx                          ;
    lda pixelx+1                        ;
    adc dxHigh,y                        ;
    sta pixelx+1                        ; pixelx += dx[dir];

    lda pixely                          ;
    clc                                 ;
    adc dyLow,y                         ;
    sta pixely                          ;
    lda pixely+1                        ;
    adc dyHigh,y                        ;
    sta pixely+1                        ; pixely += dy[dir];

    jsr plot_point                      ; plot_point(cx + pixelx, cy + pixely)

    inc i                               ;
    jmp -                               ;

; ***************************************************************************************
get_child_from_dir
    ldy treepos,x                       ;
    lda dir                             ;
    cmp dir0,x                          ;
    bne +                               ;
    lda child0,y                        ;
return3
    rts                                 ;
+
    cmp dir1,x                          ;
    bne +                               ;
    lda child1,y                        ;
    rts                                 ;
+
    cmp dir2,x                          ;
    bne +                               ;
    lda child2,y                        ;
    rts                                 ;
+
    lda #255                            ;
return2
    rts                                 ;

; ***************************************************************************************
state
    !byte 0,0,0,0
treepos
    !byte 0,0,0,0
dir0
    !byte 0,0,0,0
dir1
    !byte 0,0,0,0
dir2
    !byte 0,0,0,0
lastBlueXLow
    !byte 0,0,0,0
lastBlueXHigh
    !byte 0,0,0,0
lastBlueYLow
    !byte 0,0,0,0
lastBlueYHigh
    !byte 0,0,0,0
lastMoveXLow
    !byte 0,0,0,0
lastMoveXHigh
    !byte 0,0,0,0
lastMoveYLow
    !byte 0,0,0,0
lastMoveYHigh
    !byte 0,0,0,0
stackptr
    !byte 0,0,0,0

stack
    !byte 0,0,0,0,0,0,0,0
    !byte 0,0,0,0,0,0,0,0
    !byte 0,0,0,0,0,0,0,0
    !byte 0,0,0,0,0,0,0,0

i
    !byte 0,0,0
end
    !byte 0,0,0

; ***************************************************************************************
variables_start

; inputs
centrex
    !word 160
centrey
    !word 128
a
    !word 58
b
    !word 100
zero
    !word 0         ; padding (always zero), used to make multiply32 work on b
s
    !le32 -20       ; note: 32 bit


; workspace variables
x1
    !word 0
x2
    !word 0
ox1
    !word 0
ox2
    !word 0
y
    !word 0
aa
    !le32 0
bb
    !le32 0
bb2
    !le32 0
bd
    !le32 0
dd
    !le32 0
d1
    !le32 0
t1
    !le32 0
t2
    !le32 0
tt1
    !le32 0
tt2
    !le32 0
temp
    !le32 0
yyaa
    !le32 0
yyaa_diff
    !le32 0
aabb
    !le32 0
x1b
    !le32 0
x2b
    !le32 0
st1
    !le32 0
st2
    !le32 0
ss
    !le32 0
sb
    !le32 0
bt1
    !le32 0
bt2
    !le32 0

x
    !word 0
increment
    !word 0
pixelx
newx
    !word 0
pixely
newy
    !word 0


; ***************************************************************************************
; static data
; ***************************************************************************************
eight_times_table
    !byte 0,8,16,24
dxLow
    !byte -1, 0, 1, -1, 0, 1, -1, 0, 1
dxHigh
    !byte -1, 0, 0, -1, 0, 0, -1, 0, 0
dyLow
    !byte -1,-1,-1,0,0,0,1,1,1
dyHigh
    !byte -1,-1,-1,0,0,0,0,0,0

!src "linedata.a"
